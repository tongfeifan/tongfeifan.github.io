<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小童博客</title>
  <icon>https://www.gravatar.com/avatar/1b2c7b0d8b76186453d12ccbaf83861b</icon>
  <subtitle>童飞帆写字的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tongfeifan.github.io/"/>
  <updated>2018-10-31T10:54:04.544Z</updated>
  <id>http://tongfeifan.github.io/</id>
  
  <author>
    <name>Feifan Tong</name>
    <email>tongfeifan@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s中的https证书与权限</title>
    <link href="http://tongfeifan.github.io/2018/10/31/k8s%E4%B8%AD%E7%9A%84https%E8%AF%81%E4%B9%A6%E4%B8%8E%E6%9D%83%E9%99%90/"/>
    <id>http://tongfeifan.github.io/2018/10/31/k8s中的https证书与权限/</id>
    <published>2018-10-31T10:50:52.000Z</published>
    <updated>2018-10-31T10:54:04.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>k8s通过api-server对外提供服务，而k8s系统作为集群的调度控制中心如果没有权限控制，其安全性会有很大隐患，所以在k8s中使用了https进行认证，同时引入了RBAC作为官方推荐的权限授权和控制方式(非https端口没有权限认证)。</p><h2 id="https认证"><a href="#https认证" class="headerlink" title="https认证"></a>https认证</h2><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>为了方便后面的讨论，我们先回顾一下https的一些基础知识。https认证分为单向认证和双向认证。双向认证不仅需要服务端提供证书，客户端也需要提供证书，在两者交换证书互相确认身份之后交换密钥，然后开始加密通讯。而单向认证则不需要客户端提供证书，只需要服务端自证身份即可。k8s中使用的以双向认证为主。</p><ul><li><strong>CA根证书：</strong> CA根证书有CA中心签发，一般作为根证书，可用于签发其他证书，在k8s中可用于签发api-server的服务端证书和各个组件的客户端证书。</li><li><strong>csr：</strong> 证书签名请求（Certificate Signing Request）在申请证书时候提交的文件。包含自身信息（国家、地区、机构、名称），k8s会读取其中的机构、名称分别对应k8s中的group和user；包含主机信息（作为服务器时，接收的https请求地址与此不一致，则会拒绝）</li><li><strong>客户端/服务端证书：</strong> 该证书来自CA中心或者CA根证书根据csr内容签发，包含了公钥信息，在https握手阶段自证身份以及交换公钥。</li><li><strong>私钥文件：</strong> 私钥文件同样来自于CA中心或者CA根证书，客户端/服务端证书在被签发时，会同时颁发一个私钥文件。私钥文件用于https握手阶段交换公钥之后的通讯加密方式协商阶段。</li></ul><p>更详细的https基础知识，请自行google。</p><h3 id="证书生成工具"><a href="#证书生成工具" class="headerlink" title="证书生成工具"></a>证书生成工具</h3><p>目前在k8s部署过程中，主流使用的证书生成工具是cfssl和cfssljson。</p><h3 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h3><p>关于k8s的证书配置，网上相关的教程很多，在此不做赘述。只提部分较为关键的点。</p><ul><li>前文已经提到csr中的名称、组织（CN, O）在k8s中作为user和group使用，k8s中预设了部分角色绑定，如：clusterrole中cluster-admin已经绑定group system:master；clusterrole中的controller, schedule也已经绑定相应的user。所以在为k8s原生组件申请证书时，直接填写对应的CN或者O即可。<a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#core-component-roles" target="_blank" rel="noopener">官网罗列了预设的角色绑定</a>。k8s的角色绑定关系查询语句<code>kubectl get clusterrolebindings -o wide</code>。</li><li>k8s中预设的角色<code>system:kubelet-api-admin</code>觉有kubelet-api的权限，但是k8s没有为其绑定任何user, group，若kubelet关闭了匿名访问，开启认证后，使用类似<code>kubectl logs</code>等交互命令时可能会得到类似报错：<code>Error from server (Forbidden): Forbidden (user=kubernetes, verb=get, resource=nodes, subresource=proxy) ( pods/log busybox0-n9nbw)</code>此时解决问题的关键是将user与该角色进行绑定：<code>kubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole=system:kubelet-api-admin --user kubernetes</code>。</li><li>前文已经提到在csr中会包含主机信息，若地址与接收的http请求地址不一致时，会拒绝该请求。在为api-server编写主机信息时，经常会有遗漏，需要注意不单单要写本机host，cluster-ip也写在里面。</li></ul><h2 id="kubelet部署时的认证"><a href="#kubelet部署时的认证" class="headerlink" title="kubelet部署时的认证"></a>kubelet部署时的认证</h2><p>部分教程在部署kubelet时，没有为kubelet组件制作证书与密钥，如果学习者看到的教程没有对这一段进行解释，也许会感到疑惑。实际上kubelet的证书最终是通过kube-controller-manager签发给kubelet（kube-controller-manager 需要配置 –cluster-signing-cert-file 和 –cluster-signing-key-file 参数）。过程如下：</p><ol><li>kubeadm 通过kubeadm token create 命令创建token，并通过kubectl config命令将该token写入bootstrap文件。</li><li>kubelet在启动的时候会检查config文件，如果没有config文件，则会携带bootstrap中的token想api-server发送csr请求。</li><li>在api-server中approve该csr请求后，kube-controller-manager会签发证书与密钥给kubelete，为kubelet生成config文件，并集成证书和密钥。此时，kubelete获得了自己证书和密钥，进入了https常规交互过程。</li></ol><p>采用了该方式之后，免去了制作csr文件的繁琐步骤。另外，随着kubeadm工具的发展，以上认证步骤会变得越来越简单，甚至覆盖所有组件的部署。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;k8s通过api-server对外提供服务，而k8s系统作为集群的调度控制中心如果没有权限控制，其安全性会有很大隐患，所以在k8s中使用了h
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://tongfeifan.github.io/tags/k8s/"/>
    
      <category term="https" scheme="http://tongfeifan.github.io/tags/https/"/>
    
      <category term="容器云" scheme="http://tongfeifan.github.io/tags/%E5%AE%B9%E5%99%A8%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>容器监控利器-prometheus在生产落地过程中的思考</title>
    <link href="http://tongfeifan.github.io/2018/09/28/%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7%E5%88%A9%E5%99%A8-prometheus%E5%9C%A8%E7%94%9F%E4%BA%A7%E8%90%BD%E5%9C%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://tongfeifan.github.io/2018/09/28/容器监控利器-prometheus在生产落地过程中的思考/</id>
    <published>2018-09-28T04:20:15.000Z</published>
    <updated>2018-09-28T04:27:57.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着容器技术的不断推进，容器云也在同时不断发展，随之而来需要解决的问题便是容器及容器云的监控。目前容器监控的主流方案为prometheus。本文是在prometheus落地过程中的一些思考。</p><h2 id="社区活跃"><a href="#社区活跃" class="headerlink" title="社区活跃"></a>社区活跃</h2><p>目前容器监控的主流方案为prometheus。作为CFCN社区的第二款产品（第一款为kubernets），prometheus在社区拥有极高的支持度，容器界主流成品几乎都做到了对prometheus的原生支持。并且由于prometheus采用了pull模式，对于其他产品来说，接入成本极低，只需为prometheus提供一个pull metrics的接口即可；由此我认为开源界接入prometheus的比例会不断升高。</p><h2 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>prometheus server端实际上是一个时间序列数据库，并且提供了查询引擎promQL，promQL本身提供的查询能力较为丰富。</p><p>PromQL定义了四种数据类型，分别是instance vector(可理解为时间序列上的某一个点)，range vector(可理解为时间序列上的一段)，scalar(浮点数)，string(字符串，目前尚未使用)。PromQL便是通过操作符以及聚合函数操作这四种数据类型构成了查询表达式。</p><p>PromQL所提供的操作符，一般用于操作instance vector。除了常规的加减乘除之外，promQL还提供了Aggregation operators，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sum (calculate sum over dimensions)</span><br><span class="line">min (select minimum over dimensions)</span><br><span class="line">max (select maximum over dimensions)</span><br><span class="line">avg (calculate the average over dimensions)</span><br><span class="line">stddev (calculate population standard deviation over dimensions)</span><br><span class="line">stdvar (calculate population standard variance over dimensions)</span><br><span class="line">count (count number of elements in the vector)</span><br><span class="line">count_values (count number of elements with the same value)</span><br><span class="line">bottomk (smallest k elements by sample value)</span><br><span class="line">topk (largest k elements by sample value)</span><br><span class="line">quantile (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)</span><br></pre></td></tr></table></figure></p><p>另外PromQL到目前为止(2.4版本)还提供了30余种function，可对数据进行花样查询和聚合。</p><h3 id="报警"><a href="#报警" class="headerlink" title="报警"></a>报警</h3><p>prometheus体系中包含了报警管理- Alertmanager，Alertmanager被作为独立组件发布，独立部署。在部署Alertmanager后，只需在prometheus配置文件中配置Alertmanager的ip、port即可完成对接。Alertmanager的报警配置，依赖于promQL，同时配置报警模板以及notify通道即可使用。Alertermanager实现了报警的分组、抑制与安静功能，可以在配置之后，配合以上功能灵活地零时操作报警。目前已经集成的notify通道有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DingTalk</span><br><span class="line">IRC Bot</span><br><span class="line">JIRAlert</span><br><span class="line">Phabricator / Maniphest</span><br><span class="line">prom2teams: forwards notifications to Microsoft Teams</span><br><span class="line">SMS: supports multiple providers</span><br><span class="line">Telegram bot</span><br></pre></td></tr></table></figure></p><h3 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h3><p>prometheus在采集方面，充分发挥了其社区活跃的优势，在容器层面，google的容器信息采集器<code>cadvisor</code>对prometheus提供了非常好的支持，同时kubernets项目也原生提供了prometheus的采集接口。在机器层面的信息采集，prometheus提供了机器层面的采集器<code>node_exporter</code>。对于主流语言java, python等prometheus也提供了相应的sdk client可以方便地采集应用层与业务层的监控数据。</p><h2 id="第三方集成"><a href="#第三方集成" class="headerlink" title="第三方集成"></a>第三方集成</h2><p>Prometheus系统自身极度专注于监控，非常纯粹。然而在落地过程中实际存在着各种场景与需求，此时便需要结合一些第三方集成或定制化开发来达到我们的目的。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对于prometheus的配置，是基于yml配置文件进行的，所以每当需要操作prometheus的时候需要操作大量yml文件，关于此可考虑自行开发一个配置文件管理系统即可，也有对于的开源方案可参考：<a href="https://github.com/line/promgen" target="_blank" rel="noopener">promgen</a></p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>每当有新的监控target上线时，若是使用静态抓取配置，则需要每次修改配置项，如此操作比较麻烦，比较幸运的是prometheus集成了对主流服务发现中心/注册中心的集成，配置上对应的服务发现中心即可。</p><p>然而如果使用的服务发现中心未被prometheus集成，也无需担心，prometheus支持基于文件的服务发现，即将target配置在json文件中。prometheus会定期读取json文件，更新target列表。那么基于此，我们只需针对所使用的服务发现中心，定期拉取服务列表，更新至json文件就可实现自定义的服务发现。</p><h3 id="高可用-长期存储"><a href="#高可用-长期存储" class="headerlink" title="高可用/长期存储"></a>高可用/长期存储</h3><p>Prometheus作为一款监控产品，其server的初始定位只是用于短期存储，默认存储时间为15天，可在启动时通过<code>--storage.tsdb.retention</code>进行设定。目前prometheus自身并没有过多地考虑如何进行长期存储，但是prometheus提供了remote read 和remote write的，通过该功能可实现长期存储。</p><p>关于prometheus的长期存储方案，我认为<a href="https://github.com/improbable-eng/thanos" target="_blank" rel="noopener">Thanos</a>项目是一个较为优秀的解决方案。</p><p>在长期存储备份方面，他采用了<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar#solution" target="_blank" rel="noopener">slidecar</a>模式进行设计，通过与prometheus部署在一起的sidecar，将prometheus的存储文件备份到object storage（目前只支持gae, s3，可自行扩展）。另外Thanos可部署一个store组件， 可用来高效查询object storage。sidecar和store组件都会提供相同的store API，另外Thanos可部署一个query组件，通过store API查询sidecar或者store组件。另外query组件对外提供了与prometheus完全相同的查询dashboad与api，通过这一套方式Thanos实现了prometheus的长期存储，以及对长期存储数据和近期数据的相同查询。</p><p>另外结合Thanos，可达到prometheus的高可用部署，只需部署两台完全相同的prometheus server，便可基本达到高可用。两者唯一区别即在external_labels配置replica，那么在部署thanos query的时候添加 flag <code>--query.replica-label replica</code>即可实现在查询时候的dereplica。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着容器技术的不断推进，容器云也在同时不断发展，随之而来需要解决的问题便是容器及容器云的监控。目前容器监控的主流方案为prometheus。
      
    
    </summary>
    
    
      <category term="监控" scheme="http://tongfeifan.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="容器" scheme="http://tongfeifan.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="prometheus" scheme="http://tongfeifan.github.io/tags/prometheus/"/>
    
      <category term="落地" scheme="http://tongfeifan.github.io/tags/%E8%90%BD%E5%9C%B0/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis拦截器因pagehelper而失效的问题解决</title>
    <link href="http://tongfeifan.github.io/2018/08/01/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%9B%A0pagehelper%E8%80%8C%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://tongfeifan.github.io/2018/08/01/MyBatis拦截器因pagehelper而失效的问题解决/</id>
    <published>2018-08-01T05:29:17.000Z</published>
    <updated>2018-09-28T04:27:57.329Z</updated>
    
    <content type="html"><![CDATA[<p><code>pagehelper</code>是github开源的一款MyBatis分页插件，该插件是通过MyBatis拦截器实现的。然而使用<code>pagehelper</code>有可能会导致其他拦截器失效，今天就遇到了这个问题。</p><h2 id="事件经过"><a href="#事件经过" class="headerlink" title="事件经过"></a>事件经过</h2><h3 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h3><p>今天一到公司就有业务系统反映CAT无法记录SQL的埋点，经过mentor的提示，可能是cat客户端中的mybatis拦截器<code>catMybatisPlus</code>失效而没有上报SQL埋点，大概率和分页插件有关。</p><h3 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h3><p>于是大致瞟了一眼业务系统使用的mybatis分页插件是<code>pagehelper</code>，然后就开始搜索MyBatis多个拦截器冲突问题。直觉告诉我，这个问题应该和拦截器的执行顺序有关。</p><p>MyBatis的拦截器采用责任链设计模式，多个拦截器之间的责任链是通过动态代理组织的。我们一般都会在拦截器中的<code>intercept</code>方法中往往会有<code>invocation.proceed()</code>语句，其作用是将拦截器责任链向后传递，本质上便是动态代理的invoke。</p><p>回到<code>pagehelper</code>源码查看，可以看到其<code>inercept</code>方法直接获取了<code>excutor</code>然后开始分页查询，当查询到结果时，便返回了。在此，我们发现了关键点，那就是<code>pagehelper</code>的<code>intercept</code>方法中没有<code>invocation.proceed()</code>，这意味着什么？这意味着<code>pagehelper</code>没有继续向后传递责任链，而是自行处理直接返回。由此，我们可以猜出该问题大概率与拦截器的执行顺序有关。通过断点调试，验证了该猜想，当遇到分页查询时，执行到<code>pagehelper</code>就结束了，没有进入我们的<code>catMybatisPlugin</code>。</p><p><code>pagehelper</code>的拦截器是通过配置类<code>PageHelperAutoConfiguration</code>注册的，而非常规的通过xml文件，接着我们在<code>pagehelper</code>的配置类上注意到了一个注解<code>@AutoConfigureAfter(MybatisAutoConfiguration.class)</code>，这意味着pagehelper是最后注册的，这意味着该拦截器是在动态代理的最外层，当MyBatis开始执行SQL时，首先进入的就是pagehlper拦截器，处理返回；之后拦截器链上的拦截器不再处理。</p><h3 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h3><p>到此，问题的答案已经越来越接近，只需让<code>catMybatisPlus</code>在<code>pagehelper</code>之后注册即可。解决办法便是，仿照<code>pagehelper</code>写一个<code>catMybatisPlus</code>的配置类，在该类上使用注解<code>@AutoConfigureAfter(PageHelperAutoConfiguration.class)</code>即可。编码实现，至此，问题得以解决。</p><p>然而最后一步还有一个小插曲，一开始<code>@AutoConfigureAfter</code>并没有令<code>catMybatisPlus</code>前置注册。经过简单搜索发现<code>@AutoConfigureAfter</code>注解只可应用于autoconfigue类型的bean。而autoconfigue类型的bean一般用于spring-boot-starter导入文件，需要在<code>src/main/resources/META-INF</code>目录下的<code>spring.factories</code>声明。不过这里对我们来说，虽然不是一个spring-boot-starter，但用一下也无妨。创建<code>src/main/resources/META-INF/spring.factories</code>，声明该配置类即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该问题的解决过程不是极其艰难，不过遇到了一些比较经典的关键点，比如责任链设计模式，比如动态代理，比如spring-boot-starter的规范。在过程中，为了实现配置的先后执行，甚至又扒了一边spring bean的加载过程，企图通过改变bean的加载顺序达到目的。整个过程比较有意思，故撰文记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;pagehelper&lt;/code&gt;是github开源的一款MyBatis分页插件，该插件是通过MyBatis拦截器实现的。然而使用&lt;code&gt;pagehelper&lt;/code&gt;有可能会导致其他拦截器失效，今天就遇到了这个问题。&lt;/p&gt;
&lt;h2 id=&quot;事件经过&quot;
      
    
    </summary>
    
    
      <category term="CAT" scheme="http://tongfeifan.github.io/tags/CAT/"/>
    
      <category term="监控" scheme="http://tongfeifan.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Mybatis拦截器" scheme="http://tongfeifan.github.io/tags/Mybatis%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
      <category term="Mybatis" scheme="http://tongfeifan.github.io/tags/Mybatis/"/>
    
      <category term="分页" scheme="http://tongfeifan.github.io/tags/%E5%88%86%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>cat源码阅读(二)-设计细节解读</title>
    <link href="http://tongfeifan.github.io/2018/07/08/cat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82%E8%A7%A3%E8%AF%BB/"/>
    <id>http://tongfeifan.github.io/2018/07/08/cat源码阅读-设计细节解读/</id>
    <published>2018-07-08T05:29:17.000Z</published>
    <updated>2018-09-28T03:27:26.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CAT作为一款开源监控平台已经被许多大小公司所采用，如携程、陆金所、拍拍贷等大中型公司，以及其他各种创业公司，CAT在各大小公司一直稳定运行。这源于其优秀的细节设计。故本文将会分析CAT的一些设计细节，这些设计实现了较高的可用性，且较为复杂，值得一说。CAT主要的组成部分有： 客户端、服务端、存储几部分，下面分别对这几部分的设计做一些分析。</p><p>客户端的主要设计点有调用链和路由，服务端的主要设计点有数据分析和报表（上文已讨论），存储的主要设计点在于文件存储模块。</p><p>本文主要分析以下几点设计：</p><ol><li><a href="#客户端路由">客户端路由</a></li><li><a href="#分布式调用链设计">分布式调用链设计</a></li><li><a href="#文件存储设计">文件存储设计</a></li></ol><h2 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CAT的设计中，客户端路由是由客户端和服务器端共同实现的。通过服务端的参与，CAT实现了可在portal中动态配置服务地址；通过服务端分配<code>domain</code>与路由（此处<code>domain</code>可理解为应用名称），实现了相同<code>domain</code>的客户端消息都上报到同一台server端实例中，避免了server端互相通信等复杂设计。</p><h3 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h3><p><img src="/images/routerDesign.png" alt="routerDesign"></p><h3 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h3><p>在路由过程，我将其分为四个环节，分别是启动-&gt;获取路由-&gt;domain路由计算-&gt;构造/更新Channel。</p><p>其中启动环节只在客户端启动的时候会触发。之后三个环节除客户端启动外，也会持续地轮询执行。</p><ul><li>启动(上图1，2)：在客户端启动时，<code>ClientConfigManager</code>会从配置文件中读取serverAddress，将serverAddress交给<code>ChannelManager</code>。</li><li>获取路由（上图3）：<code>ChannelManager</code>在获取服务器地址后，会像该服务器的router接口发送请求，请求体中携带客户端名<code>domain</code></li><li>domain路由计算（上图4）：服务端在接受路由计算请求后，便会从XML或者DB中读取ip-port列表，然后会依据每个domain的hashcode分配两个ip-port给该domain（上图中代码所示）</li><li>构造/更新Channel（上图5）:服务端将分配的两个ip-port返回给客户端，由此客户端就得到了两个ip-port，客户端会将第一个ip-port作为主上报服务器，将第二个ip-port作为备份，用作failover，由此构造一个channal。</li></ul><p>经过以上四个步骤，客户端就完成了路由计算过程，<code>TcpSocketSender</code>只需获取channel，持续上报消息即可。</p><h2 id="分布式调用链设计"><a href="#分布式调用链设计" class="headerlink" title="分布式调用链设计"></a>分布式调用链设计</h2><p>CAT可以通过定制化客户端而实现对分布式调用链的跟踪。CAT的分布式调用链在服务端主要是在展示的时候得到体现，所以可以通过阅读CAT的logview部分，探索CAT的分布式调用链设计机制。另外CAT服务端会对消息的type属性的某些默认值进行特殊处理，而分布式调用链的处理，正式通过对type为<code>RemoteCall</code>的Event消息进行处理，来组合分布式调用链。</p><h3 id="logview展示消息树"><a href="#logview展示消息树" class="headerlink" title="logview展示消息树"></a>logview展示消息树</h3><p><img src="/images/CatMessageTreeShow.png" alt="CatMessageTreeShow"></p><p>通过阅读展示代码，并梳理过程得到上图，我们发现CAT的分布式调用链关键是一个type为<code>RemoteCall</code>的Event，并且可以模拟构造远程调用所形成的messageTree，如下图。</p><p><img src="/images/messageTreeRemoteCall.png" alt="messageTreeRemoteCall"></p><h3 id="如何使用分布式调用链监控"><a href="#如何使用分布式调用链监控" class="headerlink" title="如何使用分布式调用链监控"></a>如何使用分布式调用链监控</h3><p>在CAT的官方文档中，几乎没有提及如何使用CAT的分布式调用链监控。然后CAT是提供了这一功能的，并且有较好的支持。我们通过阅读源码，理解了在服务端CAT是如何展示分布式调用链的，那么在客户端自然也就可以配合实现，从而开始使用CAT的分布式调用链追踪。</p><h3 id="调用方客户端"><a href="#调用方客户端" class="headerlink" title="调用方客户端"></a>调用方客户端</h3><p>在拍拍贷内部，对okhttp进行了Aspectj编程，达成了使用okhttp包进行远程调用时的监控。核心代码段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PropertyContext context = <span class="keyword">new</span> PropertyContext();</span><br><span class="line">Cat.logRemoteCallClient(context);</span><br><span class="line"></span><br><span class="line">request = request.newBuilder()</span><br><span class="line">        .addHeader(CatConstants.HTTP_HEADER_ROOT_MESSAGE_ID, context.getProperty(Cat.Context.ROOT))</span><br><span class="line">        .addHeader(CatConstants.HTTP_HEADER_PARENT_MESSAGE_ID, context.getProperty(Cat.Context.PARENT))</span><br><span class="line">        .addHeader(CatConstants.HTTP_HEADER_CHILD_MESSAGE_ID, context.getProperty(Cat.Context.CHILD))</span><br><span class="line">        .addHeader(<span class="string">"X-PPD-CAT-APP"</span>, Cat.getManager().getDomain())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ret = proceed(request);</span><br></pre></td></tr></table></figure></p><p>通过代码可以看到，在请求中，将生成的childMessageId(可通过createMessageId方法生成)，放入header中，传递给了被调用方</p><h3 id="被调用方客户端"><a href="#被调用方客户端" class="headerlink" title="被调用方客户端"></a>被调用方客户端</h3><p>而对http被调用方，则在filter获取header，并设置当前messageTree的messageId。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PropertyContext propertyContext = <span class="keyword">new</span> PropertyContext();</span><br><span class="line">propertyContext.addProperty(Cat.Context.ROOT, request.getHeader(CatConstants.HTTP_HEADER_ROOT_MESSAGE_ID));</span><br><span class="line">propertyContext.addProperty(Cat.Context.PARENT, request.getHeader(CatConstants.HTTP_HEADER_PARENT_MESSAGE_ID));</span><br><span class="line">propertyContext.addProperty(Cat.Context.CHILD, request.getHeader(CatConstants.HTTP_HEADER_CHILD_MESSAGE_ID));</span><br><span class="line">Cat.logRemoteCallServer(propertyContext);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logRemoteCallServer</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">MessageTree tree = Cat.getManager().getThreadLocalMessageTree();</span><br><span class="line">String messageId = ctx.getProperty(Context.CHILD);</span><br><span class="line">String rootId = ctx.getProperty(Context.ROOT);</span><br><span class="line">String parentId = ctx.getProperty(Context.PARENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (messageId != <span class="keyword">null</span>) &#123;</span><br><span class="line">tree.setMessageId(messageId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (parentId != <span class="keyword">null</span>) &#123;</span><br><span class="line">tree.setParentMessageId(parentId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rootId != <span class="keyword">null</span>) &#123;</span><br><span class="line">tree.setRootMessageId(rootId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，CAT的远程调用的两个MessageTree就串起来了，这也达成了分布式调用追踪的目的。</p><h2 id="文件存储设计"><a href="#文件存储设计" class="headerlink" title="文件存储设计"></a>文件存储设计</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>CAT为了高可用、高效地进行消息存储，设计了一套文件存储结构。此文件将同一小时内上报的消息归集在一个目录进行存储,存储文件各目录内分为索引文件、数据文件两部分。系统以IP、消息上报时间小时窗口、消息树序列号（1小时内序列号）便可快速定位某一个消息。</p><h3 id="设计图-1"><a href="#设计图-1" class="headerlink" title="设计图"></a>设计图</h3><p><img src="/images/CatfileDesign.png" alt="CatfileDesign"></p><h3 id="详述-1"><a href="#详述-1" class="headerlink" title="详述"></a>详述</h3><p>消息存储文件分为索引文件、数据文件。索引文件路径结构为<code>/{yyyymmdd}/{hh24}/{domain}-{serverIP}.idex2</code>，数据文件路径结构与索引文件相比仅后缀不同，其结构为<code>/{yyyymmdd}/{hh24}/{domain}-{serverIP}.dat2</code>。</p><p>索引文件分为heander段和segment段，其中segment段便是有多个索引块顺序存储构成；而header段内每一条数据由64位存储，前32位为IP，后32位为segmentIdex。header段通过此方式维护了消息IP、segmentIndex与索引块的关系。segmentIndex可由消息树序列号(messageSeq)计算得知。因此一个消息可通过其IP、消息树序列号快速定位索引。</p><p>索引块中每一条数据，由64位存储，前40位为blockAddress, 后24位为block内offset的，通过blockAddress和blockOffset可快速定位一条messageTree在数据文件中的位置。</p><p>数据文件由多个block构成，每个block内的messageTree都上报自相同domain的客户端。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;CAT作为一款开源监控平台已经被许多大小公司所采用，如携程、陆金所、拍拍贷等大中型公司，以及其他各种创业公司，CAT在各大小公司一直稳定运行
      
    
    </summary>
    
    
      <category term="CAT" scheme="http://tongfeifan.github.io/tags/CAT/"/>
    
      <category term="监控" scheme="http://tongfeifan.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="源码阅读，架构设计" scheme="http://tongfeifan.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>cat源码阅读(一)-架构设计解读</title>
    <link href="http://tongfeifan.github.io/2018/07/06/cat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/"/>
    <id>http://tongfeifan.github.io/2018/07/06/cat源码阅读-架构设计解读/</id>
    <published>2018-07-06T05:29:17.000Z</published>
    <updated>2018-09-28T03:27:26.485Z</updated>
    
    <content type="html"><![CDATA[<p>CAT(Central Application Tracking)是基于Java开发的实时应用监控平台，为大众点评网提供了全面的监控服务和决策支持。作为大众点评网基础监控组件，它已经在中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等）中得到广泛应用，为点评各业务线提供系统的性能指标、健康状况、基础告警等。</p><p>目前拍拍贷已经有500多个应用接入了CAT监控。而我在接手CAT项目过程中，较为全面地阅读了CAT的源码，故在此分享。</p><h2 id="CAT数据结构设计"><a href="#CAT数据结构设计" class="headerlink" title="CAT数据结构设计"></a>CAT数据结构设计</h2><h3 id="Mesaage"><a href="#Mesaage" class="headerlink" title="Mesaage"></a>Mesaage</h3><p>CAT中的消息上报时的基本单位抽象类称为消息(Message)，<code>Message</code>可分为四大类，实现代码分别继承自<code>Message</code>抽象类。分别是<code>Event</code>、<code>Transaction</code>、<code>Heartbeat</code>、<code>Metric</code>。关于<code>Message</code>类的各子类含义，官方有个领域建模图可表示：<br><img src="/images/domainModel.png" alt="domainModel"></p><h3 id="消息树"><a href="#消息树" class="headerlink" title="消息树"></a>消息树</h3><p>所有消息都可被组织进消息树（MessageTree），<code>Transaction</code>类型的消息可作为消息树节点，而其他消息只可作为消息树的叶子节点。也就是<code>Transaction</code>是一个可嵌套的递归结构。结构可表示如下图：<br><img src="/images/MessageTreeStruct.png" alt="MessageTreeStruct"></p><p>有时候以时序图的方式来表示也许会更清晰：<br><img src="/images/MessageTreeTimeline.png" alt="MessageTreeTimeline"></p><p>我们可以简单理解为，若消息B为<code>Transaction</code>消息A的子节点，那么消息B就发生在A的执行期间。</p><p><code>MessageTree</code>类中的属性<code>messageId</code>表示<code>MessageTree</code>本身，其构成为：{domain}-{ip}-{timestamp}-{自增index}；另外还有两个属性，分别是<code>parentMessageId</code>, <code>rootMessageId</code>。<code>parentMessageId</code>表示开启这一段代码执行的调用方；<code>rootMessageId</code>表示这一段代码的调用方的最终源头。上图中，MessageTree2的<code>parentMessageId</code>和<code>rootMessageId</code>皆为<code>MessageTree1</code>的messageId。这两个属性在之后CAT的调用链分析与分布式调用链分析中发挥了关键作用。</p><h2 id="CAT设计"><a href="#CAT设计" class="headerlink" title="CAT设计"></a>CAT设计</h2><p>CAT系统划分为三个模块，分别是客户端、服务端、以及portal。在实际部署时，会分为<code>cat-client.jar</code>和<code>cat-home.war</code>。其中，<code>cat-client.jar</code>为客户端jar包，服务端与portal的功能都集成在<code>cat-home.war</code>中。</p><h3 id="CAT客户端设计"><a href="#CAT客户端设计" class="headerlink" title="CAT客户端设计"></a>CAT客户端设计</h3><p>CAT的客户端主要用作监控埋点，可简单分为埋点、上报两部分。<br>其设计图如下：<br><img src="/images/CATclientDesign.png" alt="CATclientDesign"></p><p>由于<code>Conext</code>维护在ThreadLocal中，因此每一个thread都会拥有一份自己的<code>Context</code>，<code>Context</code>中会维护一个stack用来存储transaction，当新transaction开启时入栈，结束时出栈。当栈内压入第一个transaction时开始构造<code>MessageTree</code>；栈空时认为一个<code>MessageTree</code>结束，此时将该<code>MessageTree</code>发送给待发送队列。</p><p>埋点部分流程如下所示：<br><img src="/images/CATclient.png" alt="CATclient"></p><p>上图可分为开始阶段和结束阶段：</p><ul><li>一场CAT的埋点始于<code>newTransaction</code>方法：<ul><li>此时会判断是否已经有<code>context</code>，<code>context</code>由ThreadLocal维护，记录当前上下文，如IP、线程号 等信息，而每个<code>context</code>中会维护一个<code>stack</code>。换句话说，CAT的一场埋点是线程隔离的。</li><li>在判断并创建<code>context</code>之后，会将新建transaction压入栈中，若此时栈为空，那么会将当前transaction记录在messageTree中，作为当前messageTree的根节点。</li><li>之后在该线程中的所有新<code>Transaction</code>、<code>Event</code>、<code>Heartbeat</code>等都会作为stack顶端transaction的子节点被记录，另外新<code>Transaction</code>操作会被压入栈中。</li></ul></li><li>而埋点的结束，是一个出栈的过程，当最终栈为空时，则认为这段埋点监控结束，将构造的整个messageTree进行flush，即分配给队列，准备上报。</li></ul><p>上报过程则是从队列中取得messageTree，进行编码，通过tcpSocket上报至服务端。</p><h3 id="CAT服务端设计"><a href="#CAT服务端设计" class="headerlink" title="CAT服务端设计"></a>CAT服务端设计</h3><p>CAT的服务端大致设计，如下<br><img src="/images/CATprocess.png" alt="CATprocess"></p><p>从图中可以看到，cat客户端的埋点数据是通过tcpsocket上报到服务端的。服务端的一切服务是通过监听上报消息开始启动。当服务端的tcpsocketReceiver收到消息以及解码后，便会创建或者寻找一个当前时间的period（在每一小时的开始会创建一个period。），如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(MessageTree tree)</span> </span>&#123;</span><br><span class="line">    String domain = tree.getDomain();</span><br><span class="line">    String ip = tree.getIpAddress();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_blackListManager.isBlack(domain, ip)) &#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = tree.getMessage().getTimestamp();</span><br><span class="line">        Period period = m_periodManager.findPeriod(timestamp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (period != <span class="keyword">null</span>) &#123;</span><br><span class="line">            period.distribute(tree);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_serverStateManager.addNetworkTimeError(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_black++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_black % CatConstants.SUCCESS_COUNT == <span class="number">0</span>) &#123;</span><br><span class="line">            Cat.logEvent(<span class="string">"Discard"</span>, domain);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这之后，period会为每一个analyzer维护一个period task，period将消息分配至每一个period task的队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">distribute</span><span class="params">(MessageTree tree)</span> </span>&#123;</span><br><span class="line">    m_serverStateManager.addMessageTotal(tree.getDomain(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    String domain = tree.getDomain();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;PeriodTask&gt;&gt; entry : m_tasks.entrySet()) &#123;</span><br><span class="line">        List&lt;PeriodTask&gt; tasks = entry.getValue();</span><br><span class="line">        <span class="keyword">int</span> length = tasks.size();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> manyTasks = length &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (manyTasks) &#123;</span><br><span class="line">            index = Math.abs(domain.hashCode()) % length;</span><br><span class="line">        &#125;</span><br><span class="line">        PeriodTask task = tasks.get(index);</span><br><span class="line">        <span class="keyword">boolean</span> enqueue = task.enqueue(tree);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enqueue == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (manyTasks) &#123;</span><br><span class="line">                task = tasks.get((index + <span class="number">1</span>) % length);</span><br><span class="line">                enqueue = task.enqueue(tree);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (enqueue == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                success = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        m_serverStateManager.addMessageTotalLoss(tree.getDomain(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后analyzer从队列中消费消息并处理。analyzer可以理解一个数据分析器，用来处理收到的Message，并聚合生成报表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyze</span><span class="params">(MessageQueue queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isTimeout() &amp;&amp; isActive()) &#123;</span><br><span class="line">        MessageTree tree = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                process(tree);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                m_errors++;</span><br><span class="line">                <span class="keyword">if</span> (m_errors == <span class="number">1</span> || m_errors % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    Cat.logError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        MessageTree tree = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                process(tree);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                m_errors++;</span><br><span class="line">                <span class="keyword">if</span> (m_errors == <span class="number">1</span> || m_errors % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    Cat.logError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CAT的设计中，所有<code>analyzer</code>可以都拥有自己的queue。因此，所有<code>analyzer</code>可以相互独立的各自分析数据。另外CAT的设计中，对于<code>analyzer</code>的扩展做得非常方便，只需要继承其<code>AbstractMessageAnalyzer</code>抽象类，并实现<code>process</code>方法，便可添加自定义的analyzer。<br>拍拍贷也通过该方式扩展统计了许多内部指标。</p><p>其中DumpAnalyzer较为特殊，它不进行任何数据处理，只用作原始数据存储。（在原始数据的文件存储这部分，CAT设计了自己的索引与存储结构，其设计较为精妙，会在后续文章中进行分析。）</p><p>CAT中一般都是以1小时作为一个时间窗口，各个analyzer会对当前小时窗口内的数据进行聚合处理，生成report表，并且在当前小时窗口内维护在内存中，在当前小时窗口结束后，将其落地写入文件或DB中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAT(Central Application Tracking)是基于Java开发的实时应用监控平台，为大众点评网提供了全面的监控服务和决策支持。作为大众点评网基础监控组件，它已经在中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等）中得到广泛应用，为点评各业务线
      
    
    </summary>
    
    
      <category term="CAT" scheme="http://tongfeifan.github.io/tags/CAT/"/>
    
      <category term="监控" scheme="http://tongfeifan.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="源码阅读" scheme="http://tongfeifan.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="架构设计" scheme="http://tongfeifan.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python中列表、迭代器、生成器的关系</title>
    <link href="http://tongfeifan.github.io/2016/03/04/Python%E4%B8%AD%E5%88%97%E8%A1%A8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://tongfeifan.github.io/2016/03/04/Python中列表、迭代器、生成器的关系/</id>
    <published>2016-03-04T05:32:40.000Z</published>
    <updated>2018-09-28T03:27:26.485Z</updated>
    
    <content type="html"><![CDATA[<p>对于Python初学者来说，列表（list）迭代器、生成器，是比较容易混淆的概念，我之前也是处于一种半迷糊的状态，所以打算好好整理一番，搞清楚其异同。<br>*<a id="more"></a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是python的内置对象，可用来存储有序序列，并且可通过索引、切片等方式，获取任意位置的值，一旦创建，则所有元素都会进入内存。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>在Python3中，迭代器是定义了<code>__next__()</code>和<code>__iter()__</code>方法的对象。迭代器，在迭代过程中，会不断的调用<code>__next()__</code>方法来获取下一个元素，因此迭代器所有元素并不需要完全进入内存。因此相对列表，性能得到优化，比如在读取一个几G的大文件时，使用迭代器，可以只将在读的文件内容放入内存中。然而，迭代器也有不可回溯，不可通过索引、切片获取元素这些特点。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器的定义形式类似于函数，然而与函数不同之处是，在其中使用了<code>yield</code>关键字。一旦在函数中使用了<code>yiled</code>关键字，该函数定义便转化成了一个生成器对象的定义。生成器在运行时，一旦遇到<code>yield</code>就会带着yield后的值/对象，切换回调用方，直到调用其<code>__next__()</code>或者<code>send()</code>才会回到生成器继续执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = g()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator object g at <span class="number">0x1033b1f10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(a)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__del__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__next__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'close'</span>, <span class="string">'gi_code'</span>, <span class="string">'gi_frame'</span>, <span class="string">'gi_running'</span>, <span class="string">'gi_yieldfrom'</span>, <span class="string">'send'</span>, <span class="string">'throw'</span>]</span><br></pre></td></tr></table></figure><h2 id="互相之间关系"><a href="#互相之间关系" class="headerlink" title="互相之间关系"></a>互相之间关系</h2><p>从以上代码，我们可以看到生成器对象是有<code>__iter__()</code>和<code>__next__()</code>方法的。因此生成器也是迭代器，<strong>反之不成立</strong>。这便是生成器与迭代器之间的关系，那么迭代器与列表是什么关系呢？相信这是一个困扰了许多人的问题。我们先来查看一些列表的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(list_obj)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__iadd__'</span>, <span class="string">'__imul__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__reversed__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'append'</span>, <span class="string">'clear'</span>, <span class="string">'copy'</span>, <span class="string">'count'</span>, <span class="string">'extend'</span>, <span class="string">'index'</span>, <span class="string">'insert'</span>, <span class="string">'pop'</span>, <span class="string">'remove'</span>, <span class="string">'reverse'</span>, <span class="string">'sort'</span>]</span><br></pre></td></tr></table></figure><p>可以看到，我们定义的列表对象<code>list_obj</code>只有<code>__iter__()</code>方法而没有<code>__next__()</code>方法，所以我们可以断定列表对象只是一个有<code>__iter()__</code>方法的可迭代对象，并不是一个迭代器。那么列表和迭代器究竟是怎样的关系。我们更近一步的查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_obj.__iter__()</span><br><span class="line">&lt;list_iterator object at <span class="number">0x1033c1be0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(list_obj.__iter__())</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__length_hint__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__next__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setstate__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure><p>不难发现，列表对象的<code>__iter__()</code>方法所返回的对象是一个迭代器。<br>其实也正是因为这个原因，使得类似于列表这样许多可迭代对象（如set，tuple等）都可以使用<code>for...in...</code>语句进行迭代。</p><h2 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h2><p>实际上<code>for...in...</code>语句是一个对可迭代对象进行遍历的语法糖，其内部实现是首先调用可迭代对象的<code>__iter()__</code>方法获取其相应迭代器对象，然后不断调用该迭代器的<code>__next__()</code>方法，直到遇到<code>StopIteration</code>异常，然后停止迭代，完成遍历。<br>过程如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_iter = list_obj.__iter__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_iter.__next__()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_iter.__next__()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_iter.__next__()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><hr><p>最后，我们来优雅地写一个斐波那契数列吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(max):</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于Python初学者来说，列表（list）迭代器、生成器，是比较容易混淆的概念，我之前也是处于一种半迷糊的状态，所以打算好好整理一番，搞清楚其异同。&lt;br&gt;*
    
    </summary>
    
    
      <category term="Python" scheme="http://tongfeifan.github.io/tags/Python/"/>
    
      <category term="编程语言" scheme="http://tongfeifan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Python3中的AsyncIO库阅读后思考</title>
    <link href="http://tongfeifan.github.io/2016/02/28/Python3%E4%B8%AD%E7%9A%84AsyncIO%E5%BA%93%E9%98%85%E8%AF%BB%E5%90%8E%E6%80%9D%E8%80%83/"/>
    <id>http://tongfeifan.github.io/2016/02/28/Python3中的AsyncIO库阅读后思考/</id>
    <published>2016-02-28T05:29:17.000Z</published>
    <updated>2018-09-28T03:27:26.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何谓异步"><a href="#何谓异步" class="headerlink" title="何谓异步"></a>何谓异步</h2><p>要搞清楚AsyncIO的实现原理，首先需要明白一些基本概念，异步（Asynchrony），详细的描述在<a href="https://en.wikipedia.org/wiki/Asynchrony_%28computer_programming%29" target="_blank" rel="noopener">维基百科</a>中有。大致翻译：</p><blockquote><p>异步是一种对于独立于主程序流的事件的处理方法。这些事件一般是外部事件，如信号到达，动作触发，而且异步不会阻塞等待结果。<br>一种处理异步的常规方式便是提供一个方法，该方法返回给调用者一个对象（一般称为<a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">future or promise</a>）用来表示一个持续进行的事件。<br>*<a id="more"></a></p></blockquote><p>恩，大致翻译如此，引用来自<a href="http://zhihu.com/question/19732473/answer/20851256?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu" target="_blank" rel="noopener">知乎</a>@<a href="https://www.zhihu.com/people/tianyishengshui" target="_blank" rel="noopener">卢毅</a>的一个通俗例子便是：</p><blockquote><p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p></blockquote><h2 id="何谓协程-coroutine"><a href="#何谓协程-coroutine" class="headerlink" title="何谓协程(coroutine)"></a>何谓协程(coroutine)</h2><p>在更细的粒度上执行的子程序，协程在同一线程上并行执行，由程序级控制其调度。在python中，通过生成器(generator)来并行执行多个协程。即通过yield关键字实现。</p><p>引用<a href="http://www.jackyshen.com/2015/05/21/async-operations-in-form-of-sync-programming-with-python-yielding/" target="_blank" rel="noopener">该处</a>的解释便是：</p><blockquote><p>任何包含<code>yield</code>关键字的函数都会自动成为生成器(generator)对象,里面的代码一般是一个有限或无限循环结构，每当第一次调用该函数时，会执行到yield代码为止并返回本次迭代结果，yield指令起到的是return关键字的作用。然后函数的堆栈会自动冻结(freeze)在这一行。当函数调用者的下一次利用next()或generator.send()或for-in来再次调用该函数时，就会从yield代码的下一行开始，继续执行，再返回下一次迭代结果。通过这种方式，迭代器可以实现无限序列和惰性求值。</p></blockquote><h2 id="Python-中的AsyncIO"><a href="#Python-中的AsyncIO" class="headerlink" title="Python 中的AsyncIO"></a>Python 中的AsyncIO</h2><p>好了，至此我们可以看一下Python3.4、3.5中的AsyncIO的实现<br>打开<code>asyncio</code>库，进入<code>__init__</code>文件，可以看到AsyncIO使用了python3.4的selectors库用于系统级别的IO切换，同时也兼顾了win32平台，为win32平台另外引入了其他模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">'win32'</span>:</span><br><span class="line">    <span class="comment"># Similar thing for _overlapped.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> _overlapped</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">import</span> _overlapped  <span class="comment"># Will also be exported.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">'win32'</span>:  <span class="comment"># pragma: no cover</span></span><br><span class="line">    <span class="keyword">from</span> .windows_events <span class="keyword">import</span> *</span><br><span class="line">    __all__ += windows_events.__all__</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">from</span> .unix_events <span class="keyword">import</span> *  <span class="comment"># pragma: no cover</span></span><br><span class="line">    __all__ += unix_events.__all__</span><br></pre></td></tr></table></figure><p>除此之外，这个package包括了其他一系列用于执行方便执行协程的模块。在此可以着重分析一下<code>base_events</code>、 <code>coroutines</code>、 <code>futures</code>、 <code>task</code>模块。</p><p>从<code>coroutines</code>模块，我们可以看出关键是<code>coroutine</code>装饰器，该装饰器将generator类型标记为 corcoutine类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Decorator to mark coroutines.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the coroutine is not yielded from before it is destroyed,</span></span><br><span class="line"><span class="string">    an error message is logged.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">   <span class="keyword">if</span> _inspect_iscoroutinefunction(func):</span><br><span class="line">        <span class="comment"># In Python 3.5 that's all we need to do for coroutines</span></span><br><span class="line">        <span class="comment"># defiend with "async def".</span></span><br><span class="line">        <span class="comment"># Wrapping in CoroWrapper will happen via</span></span><br><span class="line">        <span class="comment"># 'sys.set_coroutine_wrapper' function.</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> inspect.isgeneratorfunction(func):</span><br><span class="line">        coro = func</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">coro</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            res = func(*args, **kw)</span><br><span class="line">            <span class="keyword">if</span> isinstance(res, futures.Future) <span class="keyword">or</span> inspect.isgenerator(res):</span><br><span class="line">                res = <span class="keyword">yield</span> <span class="keyword">from</span> res</span><br><span class="line">            <span class="keyword">elif</span> _AwaitableABC <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="comment"># If 'func' returns an Awaitable (new in 3.5) we</span></span><br><span class="line">                <span class="comment"># want to run it.</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    await_meth = res.__await__</span><br><span class="line">                <span class="keyword">except</span> AttributeError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> isinstance(res, _AwaitableABC):</span><br><span class="line">                        res = <span class="keyword">yield</span> <span class="keyword">from</span> await_meth()</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>另外该模块中还有一个<code>debug_wrapper</code>， 会在开启debug模式的情况下被调用，我猜测通过这种方法，便可方便在debug模式下断点调试时也可及时看到目前<code>coroutine</code>中的值。</p><p>接下来，<code>futures</code>模块即为一个常规的futures模块，其中实现了future类，而在<code>tasks</code>模块中，则实现了对coroutine对象的wrap，将coroutine封装为future类。如此一来，便将其统一为一个抽象的future类，可被统一调度。<br>最后，结合<code>base_events</code>模块，我们来看一段典型的示例代码，并讨论一些，这段代码背后是怎么跑的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello world! (%s)'</span> % threading.currentThread())</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'Hello again! (%s)'</span> % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>以上为一段经典的，及其简单的协程调用代码。通过<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>与</code>yield from<code>， hello程序被定义成了一个coroutine，（python3.5开始，推荐</code>asnyc/await<code>关键字）然后返回一个event loop实例。通过</code>asyncio.wait()<code>，tasks（coroutine列表）被包装为Task（继承自Future的wrapper），然而作为参数传递给</code>loop.run_unitl_complite()`方法。在该方法中，Future中的任务被不断地并行来回切换执行(yield from导致的协程特性)，直到全部完成，关闭该event loop。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;何谓异步&quot;&gt;&lt;a href=&quot;#何谓异步&quot; class=&quot;headerlink&quot; title=&quot;何谓异步&quot;&gt;&lt;/a&gt;何谓异步&lt;/h2&gt;&lt;p&gt;要搞清楚AsyncIO的实现原理，首先需要明白一些基本概念，异步（Asynchrony），详细的描述在&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchrony_%28computer_programming%29&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;中有。大致翻译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异步是一种对于独立于主程序流的事件的处理方法。这些事件一般是外部事件，如信号到达，动作触发，而且异步不会阻塞等待结果。&lt;br&gt;一种处理异步的常规方式便是提供一个方法，该方法返回给调用者一个对象（一般称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;future or promise&lt;/a&gt;）用来表示一个持续进行的事件。&lt;br&gt;*
    
    </summary>
    
    
      <category term="Python" scheme="http://tongfeifan.github.io/tags/Python/"/>
    
      <category term="并发编程" scheme="http://tongfeifan.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="源码阅读" scheme="http://tongfeifan.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>xml整理（二）</title>
    <link href="http://tongfeifan.github.io/2014/11/06/xml%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tongfeifan.github.io/2014/11/06/xml整理（二）/</id>
    <published>2014-11-05T18:22:35.000Z</published>
    <updated>2018-09-28T03:27:26.485Z</updated>
    
    <content type="html"><![CDATA[<p><em>时隔两日，再次来整理XML的内容，似乎间隔有些长。终究还是不够勤快，压抑不住自己爱玩的心。今天在知乎上看到大师兄又写了一篇<a href="http://www.zhihu.com/question/26092705/answer/32989919" target="_blank" rel="noopener">答案</a>。倒不是对所提的问题有何想法，只是大师兄的某些话说到了心坎里：</em><a id="more"></a></p><blockquote><p>“你只要不想等，不愿信，你站起来，关灯，收拾干净，拍屁股走人，出来你就是铁人，没有人伤得了你，但这应该不是你想要的。</p></blockquote><blockquote><p>这世上容易的，就是看破红尘，难的，恰是命里打滚，轻而易举，说一些不痛不痒，都是没想明白。”</p></blockquote><p><em>是吧，感情也罢，梦想也罢，默默地等待，默默地付出，只觉得该为某些事情热血地追求。若自己某日，打着看破的幌子，放弃坚持的初衷。那我，还是想要为尘世的纷扰而不得解吧。等吧，等到想要的结果，等到该来的人。</em></p><blockquote><p>“在散场的最后一秒到来之前，空荡荡的剧场里走进来一个人。</p></blockquote><blockquote><p>你就一定要说：</p></blockquote><blockquote><p>等你很久啦。”</p></blockquote><p><em>扯远了，只是想来接着整理我的XML的。今天打算整理DTD, XML schema,这几项属于Schema的内容。</em></p><hr><h3 id="何谓schema"><a href="#何谓schema" class="headerlink" title="何谓schema"></a>何谓schema</h3><p>schema实际上一种描述语言，一般用于描述DBs或者XML，在此特指对XML的描述。通过Schema，可以描述XML的</p><ul><li>标签（tag）和属性（attribute）的名字</li><li>文件的结构：（元素（element）如何嵌套、哪个元素拥有哪个属性）</li><li>数据：类型（字符串？数字？）</li></ul><p>为何需要schema</p><ul><li>XML文档可以有更多可依赖的格式：结构，标签，数据类型。但同时想保持扩展性与灵活性。</li><li>可以描述怎样的数据是合法的、期待的、事先设定。</li></ul><p>对于使用schema有两种使用方式：</p><ul><li>描述型（descriptive）:为他人描述XML文档，如此，便可知道如何更好地组织数据。</li><li>规范型（prescriptive）:防止程序调用了错误的XML文档。</li></ul><hr><h3 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h3><p>DTD是在XML1.0时代的标准。DTD并不是一个典型的XML类型的文档，故而具有以下特点：</p><ul><li>不能被解析为一个DOM (Document Object Model)</li><li>无法扩展（即不能在一个DTD文档中import另一个DTD文档）</li><li>易读易写。</li></ul><h3 id="DTD如何描述XML"><a href="#DTD如何描述XML" class="headerlink" title="DTD如何描述XML"></a>DTD如何描述XML</h3><p>描述一个逻辑结构的例子：</p><ul><li>elements</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT name(#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT person(name, address+, email*)&gt;</span><br><span class="line">&lt;!ELEMENT address(city,(nr,street)?)&gt;</span><br></pre></td></tr></table></figure><ul><li>attributes</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ATTLIST name type(family|personal|place) &quot;personal&quot;&gt;</span><br></pre></td></tr></table></figure><p>此例子意为：元素name可以使用type属性，type可选值为family,personal,place，其中personal为默认值。<br>据此规范，正确的xml文档：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Bijan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> <span class="attr">type</span>=<span class="string">"personal"</span>&gt;</span>Bijan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> <span class="attr">type</span>=<span class="string">"family"</span>&gt;</span>Parsia<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不正确的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span> <span class="attr">type</span>=<span class="string">"DontKnow"</span>&gt;</span>Bijan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由此，我们可以总结，DTD描述的模板如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">element-name</span> (<span class="attr">element-content</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">element-name</span> <span class="attr">attribute-name</span> <span class="attr">attribute-type</span> <span class="attr">attribute-value</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中element-content支持使用元素名的正则表达式。</p><p>另外DTD还能描述实体引用（类似宏定义）。例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY writer &quot;Donald Duck&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="如何使用DTD"><a href="#如何使用DTD" class="headerlink" title="如何使用DTD"></a>如何使用DTD</h3><p>DTD在XML文档中有两种引入方式，一种为内嵌型（internal），另一种外置型（external）。</p><p>内嵌型的使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE cartoon[</span><br><span class="line">&lt;!ELEMENT cartoon (prolog,panels)&gt;</span><br><span class="line">...</span><br><span class="line">&lt;!ELEMENT speech(#PCDATA)&gt;]&gt;</span><br><span class="line">&lt;cartoon copyright=&quot;United Feature Syndicate&quot;&gt;</span><br><span class="line">    &lt;prolog&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/prolog&gt;</span><br><span class="line">&lt;/cartoon&gt;</span><br></pre></td></tr></table></figure><p>外置型使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE cartoon SYSTEM &quot;cartoon.dtd&quot;&gt;</span><br><span class="line">&lt;cartoon copyright=&quot;United Feature Syndicate&quot;&gt;</span><br><span class="line">    &lt;prolog&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/prolog&gt;</span><br><span class="line">&lt;/cartoon&gt;</span><br></pre></td></tr></table></figure><p>当然也可以两者同时使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE cartoon SYSTEM &quot;cartoon.dtd&quot;</span><br><span class="line">[&lt;!ATTLIST cartoon oneMore CDATA #IMPLIED&gt;]&gt;</span><br><span class="line">&lt;cartoon copyright=&quot;United Feature Syndicate&quot; oneMore=&quot;3&quot;&gt;</span><br><span class="line">&lt;prolog&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/prolog&gt;</span><br><span class="line">&lt;/cartoon&gt;</span><br></pre></td></tr></table></figure><h3 id="valid-不知如何翻译"><a href="#valid-不知如何翻译" class="headerlink" title="valid(不知如何翻译)"></a>valid(不知如何翻译)</h3><p>如果XML文件完全满足某一DTD文档，则认为该XML文档 valid w.r.t a DTD。</p><p>如果XML同时满足以下条件，则认为XML文档valid：</p><ul><li>该文档是well-formed</li><li>该文档引入了一个DTD文档</li><li>该文档valid w.r.t <strong>引入的</strong>文档</li><li>声明元素为该文档的根元素：<code>&lt;!DOCTYPE cartoon SYSTEM &quot;cartoon.dtd&quot;&gt;</code>其中的cartoon。</li></ul><hr><h3 id="什么是XML-Schema"><a href="#什么是XML-Schema" class="headerlink" title="什么是XML Schema"></a>什么是XML Schema</h3><p>XML Schema（也被称为XML Schema Definition、XSD）是DTD的替代品，并且一致认为其比DTD更加成功。相对DTD，XSD有这些特点：</p><ul><li>DTD<strong>不是</strong>well-formed XML文档，而XSD<strong>是</strong></li><li>XSD有更强的表达能力</li><li>XSD支持namespaces, datatypes(date, 06/11/2014)</li><li>XML能描述元素的复杂content。</li></ul><h3 id="XSD例子："><a href="#XSD例子：" class="headerlink" title="XSD例子："></a>XSD例子：</h3><p>DTD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!ELEMENT note (to, from, sentOn, heading, body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sentOn (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>相应XSD</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">targetNmaespace</span> = <span class="string">"http://www.w3schools.com"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span> <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span> = <span class="string">"note"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"to"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"from"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"sentOn"</span> <span class="attr">type</span>=<span class="string">"xs:date"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"body"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>###type, content, restriction and extension<br>XSD中的type可分为simpleType and complexType:</p><ul><li>simpleType可以用于属性，不带子元素或者不带属性的元素</li><li>complexType可以用于element content 或者mixed element content 或者 text content和attribuctes</li></ul><p>而content的使用：</p><ul><li>对于有属性声明的元素，我们不能使用simpleType，但是我们可以使用simpleContent来通过继承方式获得simpleType:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span> = <span class="string">"size"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:simpleCont</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:extension</span> <span class="attr">base</span> = <span class="string">"xs:integer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:attribute</span> <span class="attr">name</span> = <span class="string">"country"</span> <span class="attr">type</span> = <span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:extension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:simpleCont</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>complexContent则包含了继承或扩展自complexType的content或element。</li></ul><p>而restriction and extension则用于继承或者扩展type。从字面意义便可理解两者的区别。</p><p>更详细的内容可以参看<a href="http://www.w3schools.com/schema/schema_elements_ref.asp" target="_blank" rel="noopener">w3schools.com</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;时隔两日，再次来整理XML的内容，似乎间隔有些长。终究还是不够勤快，压抑不住自己爱玩的心。今天在知乎上看到大师兄又写了一篇&lt;a href=&quot;http://www.zhihu.com/question/26092705/answer/32989919&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;答案&lt;/a&gt;。倒不是对所提的问题有何想法，只是大师兄的某些话说到了心坎里：&lt;/em&gt;
    
    </summary>
    
    
      <category term="xml" scheme="http://tongfeifan.github.io/tags/xml/"/>
    
      <category term="course" scheme="http://tongfeifan.github.io/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>xml整理(一)</title>
    <link href="http://tongfeifan.github.io/2014/11/03/xml%E6%95%B4%E7%90%86-%E4%B8%80/"/>
    <id>http://tongfeifan.github.io/2014/11/03/xml整理-一/</id>
    <published>2014-11-03T10:02:45.000Z</published>
    <updated>2018-09-28T03:27:26.485Z</updated>
    
    <content type="html"><![CDATA[<p><em>Github博客在第一次建立之后，一直在赶作业，直到今天早上提交了两个deadline，终于松了一口气。这里接下来将是个人记录学习，以及一些想法的地方。目前计算机的课Semi-structured Data and the Web 和商学院的课Entrepreneurial Commercialisation of Knowledge 都已经结课，接下来的时间里将整理一下两门课的内容，若有空闲，则同时整理一下其他课。</em><a id="more"></a></p><hr><h3 id="何谓Semi-structured-data"><a href="#何谓Semi-structured-data" class="headerlink" title="何谓Semi-structured data"></a>何谓Semi-structured data</h3><p>根据<a href="http://en.wikipedia.org/wiki/Semi-structured_data" target="_blank" rel="noopener">维基百科</a>，semi-structured data定义如下：</p><blockquote><p>Semi-structured data is a form of structured data that does not conform with the formal structure of data models associated with relational databases or other forms of data tables, but nonetheless contains tags or other markers to separate semantic elements and enforce hierarchies of records and fields within the data. Therefore, it is also known as sef-desribing structure.</p></blockquote><p>简单说便是，半结构化数据不同于关系型数据库中的正规数据结构，而是通过tag或其他标记来区分数据元素与等级。<br>在<a href="http://en.wikipedia.org/wiki/Semi-structured_data#Types_of_Semi-structured_data" target="_blank" rel="noopener">维基百科</a>中，Semi-structured data的类型分别有XML和JSON，XML作为最经典，曾经最流行的半结构化语言，被广泛应用于各种网络服务中，而JSON则因为其可读性更强，逐渐作为XML的替代品。这里主要讨论的是XML相关技术。</p><hr><h3 id="xml相关技术内容"><a href="#xml相关技术内容" class="headerlink" title="xml相关技术内容"></a>xml相关技术内容</h3><p>Semi-structured Data and the Web课程讲述的内容是以xml为核心的所有围绕xml展开的技术。其中涉及到的技术内容包括：<br><img src="http://img02.taobaocdn.com/imgextra/i2/439962795/TB2msLEaVXXXXa_XXXXXXXXXXXX_!!439962795.png" alt="XML map"><br>在接下来的内容中，会分步逐渐解释每一项技术的内容。首先提到的自然是核心技术XML</p><hr><h3 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h3><ul><li>XML是一个W3C标准</li><li>XML被设计成<strong>simple</strong>, <strong>generic</strong> and <strong>extensible</strong></li><li>XML文件可描述<strong>structure</strong>和<strong>data</strong>，并可关联于一个<strong>DOM tree</strong></li><li>XML由element分割成更小的部分，element可包含element，elment之间存在无歧义的等级制度。</li><li>一个XML文件有一个root element和其他element组成</li></ul><p>以下为一个典型的XML文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE cartoon SYSTEM "cartoon.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cartoon</span> <span class="attr">copyright</span>=<span class="string">"United Feature Syndicate"</span> <span class="attr">year</span>=<span class="string">"2000"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prolog</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">series</span>&gt;</span>Dilbert<span class="tag">&lt;/<span class="name">series</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Scott Adams<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">characters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">character</span>&gt;</span>The Pointy-Haired Boss<span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">character</span>&gt;</span>Dilbert<span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">characters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prolog</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">panels</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">panels</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cartoon</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中第1行代码<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>为XML声明，该声明定义了XML版本为1.0，字符编码UTF-8。第2行代码<code>&lt;!DOCTYPE cartoon SYSTEM &quot;cartoon.dtd&quot;&gt;</code>为XML 类型声明（可选），其中引用一个称为Document Type Definition的语法描述文件；<code>cartoon</code>为必须为文件的root element。</p><h3 id="XML-elements"><a href="#XML-elements" class="headerlink" title="XML elements"></a>XML elements</h3><p>element 定义</p><ul><li>element由标签界定</li><li>标签在尖括号中</li><li>标签区分大小写。e.g., <from>和<from>是不同的</from></from></li><li>标签可分为开始标签&lt;…&gt;和结束标签</li><li>element有一对开始标签与结束标签所界定</li><li>element具有属性(attribute)。e.g., </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cartoon</span> <span class="attr">copyright</span>=<span class="string">"United Feature Sndicate"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>element概念</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element-name</span> <span class="attr">attr-decl1</span> <span class="attr">...</span> <span class="attr">attr-decln</span>&gt;</span></span><br><span class="line">    content</span><br><span class="line"><span class="tag">&lt;/<span class="name">element-name</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>允许多个属性。</li><li>属性声明格式<code>attr-name=&quot;attr-value&quot;</code>。</li><li>一个element中，每个属性最多只允许出现一次。</li><li>content可以为<strong>空</strong><1>，可以为<strong>text</strong><2>，可以为一或多个<strong>element</strong><3>。<br>其中<2>称为simple content，<3>称为element content，<2>+<3>称为mixed content。</3></2></3></2></3></2></1></li><li>空元素可以写做。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element-name</span> <span class="attr">attr-decl1</span> <span class="attr">...</span> <span class="attr">attr-decln</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Well-formed XML document</p><ul><li>只有一个root element。</li><li>标签,&lt;,&gt;是正确的（包括在字符串数据中没有&lt;或&amp;）。</li><li>标签以正确的方式嵌套。</li><li>对每一个标签来说，属性都是唯一的，且属性值在引号内。</li><li>标签内没有注释。<br>Well-formed是一个XML最基本的要求，只有如此，XML才能被解析成树。</li></ul><hr><p><em>今天先整理XML文件的相关内容，下一次我们来讲一讲关于 Schema的相关内容，其中将会涉及到DTD、XML Schema、RelaxNG。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Github博客在第一次建立之后，一直在赶作业，直到今天早上提交了两个deadline，终于松了一口气。这里接下来将是个人记录学习，以及一些想法的地方。目前计算机的课Semi-structured Data and the Web 和商学院的课Entrepreneurial Commercialisation of Knowledge 都已经结课，接下来的时间里将整理一下两门课的内容，若有空闲，则同时整理一下其他课。&lt;/em&gt;
    
    </summary>
    
    
      <category term="xml" scheme="http://tongfeifan.github.io/tags/xml/"/>
    
      <category term="course" scheme="http://tongfeifan.github.io/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>Hello-World!</title>
    <link href="http://tongfeifan.github.io/2014/10/31/Hello-World-0/"/>
    <id>http://tongfeifan.github.io/2014/10/31/Hello-World-0/</id>
    <published>2014-10-31T10:10:25.000Z</published>
    <updated>2018-09-28T03:27:26.485Z</updated>
    
    <content type="html"><![CDATA[<p>It’s my fisrt blog. I want to record the learning path during my PG year.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It’s my fisrt blog. I want to record the learning path during my PG year.&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
